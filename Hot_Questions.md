# 八股文高频问题

# 《C语言基础》
## 变量命名规则为
- 由字母、下划线、数字组成，且不能由数字开头

## GCC编译步骤
1. 预处理 -E 展开宏、包头文件、替换条件编译、删除注释等， 产生.i文件
2. 编译   -S 检查语法错误， 产生.s文件
3. 汇编   -c 将汇编指令翻译成机器源码， 产生二进制机器码文件.o文件
4. 链接   该阶段最重要的是库函数（静态库和动态库），将二进制机器码文件.o文件与静态库或者动态库文件，进行拼接，产生可执行文件.out文件


## strlen & sizeof
- strlen 是一个函数，用于计算字符串中字符的个数，不包括字符串结束符 '\0'，运行时计算。
- sizeof 是一个运算符，用于计算数据类型或变量的大小（占用的字节数），编译时计算。

## const关键字
- const & define
  - const可以用来声明一个变量或者函数参数为常量,提供类型安全，因为它具有数据类型，编译器会进行类型检查.
  - define在预处理阶段进行字符串替换，没有类型检查.
- 指针常量 & 常量指针(识别技巧： 先看到谁就读谁)
    - 指针常量：int *const p ---> *在const前出现，const修饰变量p,p的值不可变即它所指的方向不可变（address），但它所指向的里值可变（*p,value）
    - 常量指针：int const * p ---> const出现在*前，const修饰值*p,那么p所指向的内容不可变（*p），但指向的方向可以变化（address）

## static关键字
- 静态全局变量仅对当前文件可见，其他文件不可访问,如果没有赋值，编译器自动为其初始化，存储在数据段（静态存储区）
- 静态函数只能在声明它的文件中可见，其他文件不能引用该函数

## volatile关键字
用于声明一个变量，当该变量的值可能在程序的正常控制流之外发生变化时，例如由硬件设备、中断服务程序或者其他并发线程修改。
使用 volatile 告诉编译器不要对该变量进行优化，以确保每次访问该变量时都从内存中读取最新的值。
  
## extern关键字
- 用于声明外部变量或函数，表示此变量或函数是在其他文件中定会一的，需要在当前文件中引用

## strcpy & strncpy
- strcpy:
    - 不安全：它不检查 strDestination 中是否有足够的空间，可能导致缓冲区溢出。

## 指针 & 数组
- 指针与一维数组的操作一致，区别：指针是变量，数组名是常量数组名不能出现在等号左边。
- 数组指针：指向整个数组空间（例如：int arr[2];int *p=arr,p是数组指针）
  - 当为一维数组时，数组名=指针指向的数组的第一个元素；在二维数组中，数组名=指针，但是不再是指向数组的第一个元素，而是指向的是第一个子数组（第一排数组）。
- 指针数组：数组的每一个元素都是指针（如： int *ptrArr[5]）

## 值传递 & 地址传递
- 值传递：指在函数调用时，将实际参数的值复制一份传递给函数的形式参数，在函数内部对参数的操作不会影响到实际参数的值，形式参数和实际参数指向不同的内存位置。
- 地址传递： 在地址传递中，函数调用时，实际参数的地址（或引用）被传递给形式参数，形式参数和实际参数指向相同的内存位置，在函数内部对参数的操作会影响到实际参数的值。

## 函数指针 & 指针函数
- 函数指针：函数指针是指指向函数的指针变量，通过该指针调用相应的函数。
    - typedef int (*Operation)(int, int);int add(int a, int b) { return a + b;} ---> op = add;  // 将 add 函数的地址赋给op result = op(5, 3); // 通过 op 调用 add 函数
- 指针函数：指针函数是一个返回指针的函数。它实际上是一个函数，返回值类型是一个指针。
    - int* create_array(int size){...}

## 静态链接 & 动态链接
1. 静态链接在编译阶段完成，动态链接在程序运行时完成
2. 静态链接可执行文件包含了所有的目标代码和库函数代码，占用内存大，加载速度快
3. 动态链接生成的可执行文件更小，但更依赖于系统中已安装的共享库，加载速度慢

## C语言的内存对齐
- 为什么要对齐？各个硬件平台对存储空间的处理上有很大的不同，如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失
- 预编译指令#pragmapack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的
- #pragma pack () /*取消指定对齐，恢复缺省*/

## Linux用户空间的分布
- 代码段： 存放二进制可执行文件
- 数据段(.data)： 包含了程序中已经初始化的全局变量和静态变量等
- .bss段： 程序未初始化数据段包含了程序中未初始化的全局变量和静态变量等
- 堆段： 用于动态分配内存的区域
- 文件映射和匿名映射段： 包括动态库和共享内存等
- 栈段： 存储函数调用信息和局部变量的区域，存储函数的参数、返回地址和局部变量等信息。

## C语言中，内存泄露的原因
1. 动态分配的内存没有被释放：当你使用malloc，calloc或realloc函数动态分配内存后，如果你没有使用free函数来释放这些内存，那么这些内存就会一直存在，直到程序结束。这就是内存泄露。 
2. 指针赋值问题：如果指针指向动态分配的内存块，然后该指针被重新赋值而没有释放原来的内存，就会导致内存泄露。 
3. 重复释放内存：如果你试图释放已经被释放的内存，可能会导致程序崩溃。
4. 循环引用：如果存在循环引用的数据结构，例如双向链表，可能会导致内存泄露，因为即使没有指向数据结构的指针，它们仍然相互引用，导致内存无法释放。

## 大小端存储方式
- 大端：大端序是一种将数据的高位字节存储在内存低地址处，而低位字节存储在内存高地址处的字节存储顺序。
    - 内存地址: 0x1000 0x1001 0x1002 0x1003
    - 数据内容: 12 34 56 78
- 小端：与大端相反
    - 内存地址: 0x1000 0x1001 0x1002 0x1003
    - 数据内容: 78 56 34 12
- 如何区分：
    - 通过检查变量的内存表示来判断CPU的字节序
    - 定义一个多字节整数，转换类型访问该变量的各个字节
    - 检查各个字节的值以确定字节序。
![Endianness](大小端测试.png "大小端存储方式示意图")

# 《OS》
# 网络系统
## 零拷贝
- 旨在解决数据传输过程的系统性能和资源利用效率差的问题，减少CPU的负载和内存的消耗
- 网络数据传输中，
  
## DMA技术
- I/O设备和内存进行数据传输的时候，数据搬运的工作交给DMA控制器，而CPU不再参与数据搬运相关的事物，CPU去处理别的事物。

## i/o多路复用（select、poll、epoll）
- 单线程或单进程中监听多个I/O事件的机制
- 使用系统调用函数（select、poll、epoll）同时监听多个I/O事件，一旦其中任何一个I/O操作就绪，立刻通知进程做相应处理
- select
- poll
- epoll

# 内存管理
## 什么是虚拟内存？
- 虚拟内存是一种计算机系统内存管理技术，通过将物理内存和磁盘存储结合，使得程序可以使用比实际物理内存更大的地址空间。
- 操作系统通过内存分页机制，将程序的虚拟地址空间划分为固定大小的页，并通过页表将这些虚拟页映射到物理内存或磁盘上的页面文件。
- 当程序访问的虚拟页不在物理内存中时，发生页面调度，将所需页面从磁盘加载到内存，从而实现按需分配内存。
- 虚拟内存提供了进程隔离和内存保护，确保每个进程运行在自己的虚拟地址空间中，避免相互干扰。此外，它还提高了内存利用率，允许操作系统在内存不足时使用磁盘作为后备存储，减少内存碎片并优化系统性能。
## 虚拟内存和物理内存的映射关系管理方式？
- 虚拟内存和物理内存的映射关系管理主要通过页表（Page Table）实现。虚拟内存允许每个进程拥有一个独立的地址空间，使得程序在执行时不必考虑物理内存的限制。
- 页表将虚拟地址映射到物理地址，其中虚拟地址被分成页（Page），物理地址被分成页框（Frame）。
- 当CPU需要访问某个虚拟地址时，首先通过页表查找对应的物理地址，如果所需的页不在内存中，则触发缺页中断，由操作系统将所需页从磁盘调入内存。
  
## 介绍Linux内核空间和用户空间
- 在Linux操作系统中，内核空间和用户空间是两个独立的运行环境，分别负责不同的任务。
- 内核空间是操作系统核心代码运行的地方，它具有最高权限，直接管理硬件资源，如CPU、内存、设备驱动和文件系统。
- 用户空间是普通应用程序运行的环境，它们通过系统调用接口与内核进行交互。用户空间程序运行时受到内核的保护，不能直接访问硬件资源，这样的设计提高了系统的稳定性和安全性，防止用户程序由于错误或恶意操作影响整个系统的运行。

## Linux内核空间和用户空间通信方式
-  系统调用: 系统调用是用户空间进程与内核交互的主要机制。用户空间进程可以通过系统调用请求内核提供的服务，例如文件操作、进程控制和内存管理。
-  设备文件： 通过设备文件，用户空间进程可以与内核中的设备驱动程序通信。设备文件通常位于 /dev 目录下，用户进程可以使用常规的文件操作（如 open、read、write 和 ioctl）与设备文件进行交互。
-  共享内存
-  消息队列
-  信号
-  管道
  
## 介绍MMU
- MMU（内存管理单元）是计算机系统中的一种硬件组件，负责管理虚拟内存和物理内存之间的映射。
- 它通过页表（Page Table）将虚拟地址转换为物理地址，实现虚拟内存的功能，从而允许每个进程拥有独立的地址空间。
- MMU在内存访问时检查相应的页表项，以确定虚拟地址是否有效并找到对应的物理地址，如果页表中没有找到对应的物理地址，则触发缺页异常，由操作系统处理。
- MMU还支持内存保护、缓存控制和地址转换缓冲（TLB）等功能，进一步优化了内存管理性能。
## 堆和栈的区别
- 
## malloc分配内存的方式
## 如果内存不足了该怎么办
- 直接释放：操作系统会尝试直接释放一些不再需要的内存资源，例如通过垃圾回收机制清理无用的缓存或临时数据。
- 后台进程：操作系统可能会将一些不活跃的后台进程置于休眠状态或直接终止，以腾出更多的内存供当前活动的进程使用。
- 触发OOM（Out Of Memory）杀手：当内存严重不足且无法通过前两种方式解决时，操作系统会触发OOM杀手机制，强制终止一些内存消耗较大的进程，以确保系统的稳定运行。这种机制通常会选择那些优先级较低、占用内存较多的进程进行终止，以最小化对用户体验的影响。
  
# 进程管理
## 自旋锁与互斥量的区别
- 使用自旋锁的进不会睡眠，而使用信号量的进程会睡眠。
- 使用自旋锁时，线程处于忙等状态，浪费cpu资源；使用互斥锁时，线程处于祖册状态，释放CPU资源。
- 在中断服务程序中的互斥使用自旋锁？？？？？？？？？？？？？？？？？？？？？？？？？？？
  
# 文件系统管理
  
# 《网络协议栈》

# 《ARM基础》

# 《驱动》
## file_operation结构体是内核驱动操作函数的集合
## compatible属性的作用
- 它的值得是字符串列表，他的作用是将设备和驱动绑定起来
## 什么是交叉编译工具链？
- 在一种架构上编译另外一种架构的代码，使得运行架构下生成的执行文件，能够在目标架构下运行该执行文件。
## Linux中断
  
## linux设备和驱动如何匹配？
- 一般如果系统用了设备树，那就是比较compatible属性，设备节点和驱动匹配成功后自动执行prob函数。如果没用设备树，那就是比较name字段，实际两者比较的都是字符串，相当于名字一样算匹配成功.

# 《系统和根文件系统移植》
## 什么是ubootloader?
- 引导加载程序。它能够识别和加载操作系统内核、初始化硬件设备并设置一些基本参数等
- 此过程有两个阶段
  - 阶段1: 汇编，初始化C怨言环境，初始化DDR，设置栈指针sp等
  - 阶段2: 完成硬件初始化，建立内存映射，将内核Image和设备数文件读取到内存DDR，然后启动内核
## uboot的启动过程？
- 加载kernel的Image。从外部flash中的内核镜像和设备树文件加载至DDR
- 设置启动参数bootargs和biootcmd。
- 启动内核。uboot将启动参数传入内核，并将执行权限交给内核。
## bootargs和bootcmd
- bootargs：它保存着uboot传递给linux内核的参数。
- bootcmd:  它保存着uboot的默认命令，这写命令用于linux内核的启动，可以在uboot启动后进入命令设置。

# 《Linux常用命令》


