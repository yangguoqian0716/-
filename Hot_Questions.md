# 八股文高频问题

# C语言基础
### C语言中，内存泄露的原因
1. 动态分配的内存没有被释放：当你使用malloc，calloc或realloc函数动态分配内存后，如果你没有使用free函数来释放这些内存，那么这些内存就会一直存在，直到程序结束。这就是内存泄露。 
2. 指针赋值问题：如果指针指向动态分配的内存块，然后该指针被重新赋值而没有释放原来的内存，就会导致内存泄露。 
3. 重复释放内存：如果你试图释放已经被释放的内存，可能会导致程序崩溃。
4. 循环引用：如果存在循环引用的数据结构，例如双向链表，可能会导致内存泄露，因为即使没有指向数据结构的指针，它们仍然相互引用，导致内存无法释放。

### GCC编译步骤
1. 预处理 -E 展开宏、包头文件、替换条件编译、删除注释等， 产生.i文件
2. 编译   -S 检查语法错误， 产生.s文件
3. 汇编   -c 将汇编指令翻译成机器源码， 产生二进制机器码文件.o文件
4. 链接   该阶段最重要的是库函数（静态库和动态库），将二进制机器码文件.o文件与静态库或者动态库文件，进行拼接，产生可执行文件.out文件

### 静态链接和动态链接的区别
1. 静态链接在编译阶段完成，动态链接在程序运行时完成
2. 静态链接可执行文件包含了所有的目标代码和库函数代码，占用内存大，加载速度快
3. 动态链接生成的可执行文件更小，但更依赖于系统中已安装的共享库，加载速度慢

### C语言的内存对齐
- 为什么要对齐？各个硬件平台对存储空间的处理上有很大的不同，如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失
- 预编译指令#pragmapack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的
- #pragma pack () /*取消指定对齐，恢复缺省*/

### static关键字
### extern关键字
### Linux用户空间的分布
- 代码段： 存放二进制可执行文件
- 数据段： 包含了程序中已经初始化的全局变量和静态变量等
- bss段：  程序未初始化数据段包含了程序中未初始化的全局变量和静态变量等
- 堆段： 用于动态分配内存的区域
- 文件映射和匿名映射段： 包括动态库和共享内存等
- 栈段： 存储函数调用信息和局部变量的区域，存储函数的参数、返回地址和局部变量等信息。
# OS
### 零拷贝
- 旨在解决数据传输过程的系统性能和资源利用效率差的问题，减少CPU的负载和内存的消耗
- 网络数据传输中，
### DMA技术
- I/O设备和内存进行数据传输的时候，数据搬运的工作交给DMA控制器，而CPU不再参与数据搬运相关的事物，CPU去处理别的事物。
### i/o多路复用（select、poll、epoll）
###


