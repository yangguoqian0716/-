# 八股文高频问题
# 《C语言基础》
## 变量命名规则为
- 由字母、下划线、数字组成，且不能由数字开头
## GCC编译步骤
1. 预处理 -E 展开宏、包头文件、替换条件编译、删除注释等， 产生.i文件
2. 编译   -S 检查语法错误， 产生.s文件
3. 汇编   -c 将汇编指令翻译成机器源码， 产生二进制机器码文件.o文件
4. 链接   该阶段最重要的是库函数（静态库和动态库），将二进制机器码文件.o文件与静态库或者动态库文件进行拼接，产生可执行文件.out文件
## strlen & sizeof
- strlen 是一个函数，用于计算字符串中字符的个数，不包括字符串结束符 '\0'，运行时计算。
- sizeof 是一个运算符，用于计算数据类型或变量的大小（占用的字节数），编译时计算。
## const关键字
### const & define
  - const可以用来声明一个变量或者函数参数为常量,提供类型安全，因为它具有数据类型，编译器会进行类型检查.
  - define在预处理阶段进行字符串替换，没有类型检查.
## 指针常量 & 常量指针(识别技巧： 先看到谁就读谁)
    - 指针常量：int *const p ---> *在const前出现，const修饰变量p,p指针本身是常量，不能改变指向的地址，可以通过指针修改其指向的内容。
    - 常量指针：int const * p ---> const出现在*前，const修饰值*p,指针所指向的内容是常量，不能通过指针修改内容。指针本身不是常量，可以指向其他地址。
## static关键字
1. static修饰的局部变量：默认初始化为零或空指针。作用域仍然是定义它的函数或代码块内。生命周期扩展至整个程序运行周期。存储在bss段。（原本存在栈区）
2. static修饰的全局变量：默认初始化为零或空指针。作用域被限制在定义它的文件中，不能被其他文件访问。存储在bss段。
3. static修饰的函数：作用域被限制在定义它的文件中，不能被其他文件调用。存储在代码段。
## volatile关键字
用于声明一个变量，当该变量的值可能由硬件设备、中断服务程序或者其他并发线程修改时，使用 volatile 告诉编译器不要对该变量进行优化，以确保每次访问该变量时都从内存中读取最新的值。
## extern关键字
- 用于声明外部变量或函数，表示此变量或函数是在其他文件中定会一的，需要在当前文件中引用
## strcpy & memcpy
- 用途：strcpy用于复制字符串，即以空字符'\0'结尾的字符数组；用于复制任意类型的数据，按字节进行复制。
- 安全性：strcpy目标缓冲区是否有足够的空间来容纳源字符串及其终止的空字符，如可能导致缓冲区溢出；memcpy需要指定要复制的字节数，确保目标缓冲区足够大。
## 数组名与指针的区别
- 数组名是常量指针，指向数组首元素；指针是一个变量，存储一个内存地址。
- 数组名大小固定为整个数组的大小；大小固定为指针类型的大小。
- 无法被改变或重新赋值；可以被改变或重新赋值。
- 无法进行指针运算；可以进行指针运算。
## 野指针的产生（valgrind可调试）
- 指针变量未初始化
- 指针指向的内存已经被释放（释放内存后将指针置为NULL）
- 指针越界
## 指针 & 数组
- 指针与一维数组的操作一致，区别：指针是变量，数组名是常量数组名不能出现在等号左边。
- 数组指针：指向整个数组空间（例如：int arr[2];int *p=arr,p是数组指针）
  - 当为一维数组时，数组名=指针指向的数组的第一个元素；在二维数组中，数组名=指针，但是不再是指向数组的第一个元素，而是指向的是第一个子数组（第一排数组）。
- 指针数组：数组的每一个元素都是指针（如： int *ptrArr[5]）
## 值传递 & 地址传递
- 值传递：指在函数调用时，将实际参数的值复制一份传递给函数的形式参数，在函数内部对参数的操作不会影响到实际参数的值，形式参数和实际参数指向不同的内存位置。
- 地址传递： 在地址传递中，函数调用时，实际参数的地址（或引用）被传递给形式参数，形式参数和实际参数指向相同的内存位置，在函数内部对参数的操作会影响到实际参数的值。
## 函数指针 & 指针函数
- 函数指针：函数指针是指指向函数的指针变量，通过该指针调用相应的函数。
    - typedef int (*Operation)(int, int);int add(int a, int b) { return a + b;} ---> op = add;  // 将 add 函数的地址赋给op result = op(5, 3); // 通过 op 调用 add 函数
- 指针函数：指针函数是一个返回指针的函数。它实际上是一个函数，返回值类型是一个指针。
    - int* create_array(int size){...}
## 静态链接 & 动态链接
1. 静态链接在编译阶段完成，动态链接在程序运行时完成
2. 静态链接可执行文件包含了所有的目标代码和库函数代码，占用内存大，加载速度快
3. 动态链接生成的可执行文件更小，但更依赖于系统中已安装的共享库，加载速度慢
## C语言的内存对齐
- 为什么要对齐？各个硬件平台对存储空间的处理上有很大的不同，如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失
- 预编译指令#pragmapack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的
- #pragma pack () /*取消指定对齐，恢复缺省*/

## C语言中，内存泄露的原因
1. 动态分配的内存没有被释放：当你使用malloc，calloc或realloc函数动态分配内存后，如果你没有使用free函数来释放这些内存，那么这些内存就会一直存在，直到程序结束。这就是内存泄露。 
2. 指针赋值问题：如果指针指向动态分配的内存块，然后该指针被重新赋值而没有释放原来的内存，就会导致内存泄露。 
3. 重复释放内存：如果你试图释放已经被释放的内存，可能会导致程序崩溃。
4. 循环引用：如果存在循环引用的数据结构，例如双向链表，可能会导致内存泄露，因为即使没有指向数据结构的指针，它们仍然相互引用，导致内存无法释放。

## 如何检查内存泄漏
- 使用valgrind工具，valgrind --leak-full=yes ./xxx（可执行程序）
- gdb

## 大小端存储方式
- 大端：大端序是一种将数据的高位字节存储在内存低地址处，而低位字节存储在内存高地址处的字节存储顺序。
    - 内存地址: 0x1000 0x1001 0x1002 0x1003
    - 数据内容: 12 34 56 78
- 小端：与大端相反
    - 内存地址: 0x1000 0x1001 0x1002 0x1003
    - 数据内容: 78 56 34 12
- 如何区分：
    - 通过检查变量的内存表示来判断CPU的字节序
    - 定义一个多字节整数，转换类型访问该变量的各个字节
    - 检查各个字节的值以确定字节序。
![Endianness](大小端测试.png "大小端存储方式示意图")






# 《OS》
# 网络管理
## 零拷贝
- 旨在解决数据传输过程的系统性能和资源利用效率差的问题，减少CPU的负载和内存的消耗
- 网络数据传输中，
  
## DMA技术
- I/O设备和内存进行数据传输的时候，数据搬运的工作交给DMA控制器，而CPU不再参与数据搬运相关的事物，CPU去处理别的事物。

## i/o多路复用（select、poll、epoll）
- 单线程或单进程中监听多个I/O事件的机制
- 使用系统调用函数（select、poll、epoll）同时监听多个I/O事件，一旦其中任何一个I/O操作就绪，立刻通知进程做相应处理
- select
- poll
- epoll

# 内存管理
## malloc的底层实现
Linux下：
- 开辟空间小于128k时，通过brk()函数
## 用户态和内核态的区别
- 内核态下，CPU可以执行所有的指令和访问所有的硬件资源。此模式下的操作具有更高的权限，主要用于操作系统内核的运行。内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。
- 用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。
  
## 什么是虚拟内存？
- 是操作系统提供给每个运行中程序的一种地址空间，每个程序在运行时认为自己拥有的内存空间就是虚拟内存，其大小远大于实际的物理内存大小。
- 虚拟内存划分为固定大小的段或者页，并将这些段或者页映射到物理内存的不同位置，如果物理内存中找不到相应的页，则发生缺页异常，陷入至内核空间，分配物理内存。使得程序在运行时可以更高效地利用物理内存。
  
## 虚拟地址是怎么转化到物理地址的？
- 虚拟地址转化到物理地址是由MMU管理完成的。
- 在虚拟地址转换过程中，通常使用页表来进行映射。页表是一种数据结构，存储在内存中。它将虚拟地址划分为固定大小的页（linux下为4KB），对应物理地址的页框。每个页表项纪录虚拟页和物理页的映射关系。
- 当程序访问一个虚拟地址时，MMU将虚拟地址分解为页号和页内偏移量。然后，MMU查找页号表，根据页号找到对应的页表项。页表项中包含物理页的基地，MMU将物理页的基地址与页内偏移量组合，得到对应的物理地址。
- 虚拟地址转化为物理地址的过程中，可能还涉及多级页表、快表等机制，以提高地址转换的效率。
  
## Linux进程的用户空间的分布
![Endianness](32位虚拟内存布局.png "虚拟空间内存分布")
- 代码段： 存放二进制可执行文件
- 数据段(.data)： 包含了程序中已经初始化的全局变量和静态变量等
- .bss段： 程序未初始化数据段包含了程序中未初始化的全局变量和静态变量等
- 堆段： 用于动态分配内存的区域
- 文件映射和匿名映射段： 包括动态库和共享内存等
- 栈段： 存储函数调用信息和局部变量的区域，存储函数的参数、返回地址和局部变量等信息。
  
## 介绍MMU
- MMU（内存管理单元）是计算机系统中的一种硬件组件，负责管理虚拟内存和物理内存之间的映射。
- 它通过页表（Page Table）将虚拟地址转换为物理地址，实现虚拟内存的功能，从而允许每个进程拥有独立的地址空间。
- MMU在内存访问时检查相应的页表项，以确定虚拟地址是否有效并找到对应的物理地址，如果页表中没有找到对应的物理地址，则触发缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。
- MMU还支持内存保护、缓存控制和地址转换缓冲（TLB）等功能，进一步优化了内存管理性能。
  
## 堆和栈的区别
- 内存分配方式
  - 栈： 栈内存通常在程序编译时确定，大小固定。栈内存由编译器自动管理，函数调用时分配，函数返回时释放。
  - 堆： 堆内存在运行时分配，大小可以动态改变。堆内存需要手动分配和释放。
- 生命周期
  - 栈： 栈上的变量在其作用域结束时自动销毁。当函数返回时，所有在函数内分配的栈内存都会被释放。
  - 堆： 堆上的变量在手动释放之前会一直存在，生命周期由程序员控制。如果没有正确释放堆内存，会导致内存泄漏。
- 访问方式
  - 栈： 栈内存的访问速度很快，因为它们是按顺序存储的，CPU可以通过栈指针快速访问。栈空间较小，通常由操作系统设定一个固定的大小限制。
  - 堆： 堆内存的访问速度相对栈内存较慢，因为它们在内存中是随机存储的，CPU需要通过指针访问。堆空间较大，主要受限于系统的可用内存。
    
## 如果内存不足了该怎么办
- 直接释放：操作系统会尝试直接释放一些不再需要的内存资源，例如通过垃圾回收机制清理无用的缓存或临时数据。
- 后台进程：操作系统可能会将一些不活跃的后台进程置于休眠状态或直接终止，以腾出更多的内存供当前活动的进程使用。
- 触发OOM（Out Of Memory）杀手：当内存严重不足且无法通过前两种方式解决时，操作系统会触发OOM杀手机制，强制终止一些内存消耗较大的进程，以确保系统的稳定运行。这种机制通常会选择那些优先级较低、占用内存较多的进程进行终止，以最小化对用户体验的影响。
  
# 进程管理
## Linux的fork的作用
- fork是一个系统调用，用于创建新的进程。
- 调用fork会生成一个新的子进程，子进程从父进程继承了代码、数据、堆栈以及其他进程上下文信息，还会拥有父进程打开的文件描述符和其他系统资源。
- 在父进程中，返回子进程的进程ID；在子进程中，返回值为0。
## 进程和线程的区别
- 本质：进程是资源分配的基本单位；线程是任务调度的基本单位
- 开销：进程都有独立的代码和数据空间，程序间切换开销大；同类线程共享代码和数据空间，仅有独立的运行栈和程序计数器，线程之间切换开销小。
- 稳定性：进程中子进程的崩溃不影响其他进程；同一进程中的某一线程崩溃，可能会导致整个进程崩溃。

## 进程切换和线程切换的区别？
- 进程切换涉及内容较多，包括进程的地址空间、全局变量、文件描述符等，还包括了内核堆栈、寄存器等内核空间的资源。
- 线程切换只切换它的栈、寄存器、计数器等，不需要切换地址空间。

## 进程上下文有哪些？
- CPU上下文包括CPU寄存器和程序计数器。CPU寄存器：CPU 内部一个容量小，但是速度极快的缓存。程序计数器：存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
- CPU执行的任务有：线程、进程、中断。顾根据任务不同，将CPU上下文切换划分为：进程上下文切换、线程上下文切换、中断上下文切换。
- CPU上下文切换就是将前一个任务的CPU上文保存起来，然后加载新任务的上下文，然后跳转到程序计数器所指的新位置，运行新任务。当旧任务再此被调度器分配给CPU运行时，CPU重新加载此上下文，按照原来保存时的状态继续运行，状态不受影响。

## 进程间通信方式
- 管道、消息队列、共享内存、信号、信号量、socket
## 并发控制机制（线程间通信方式）（linux中的同步机制？）
原子操作、锁（自旋锁、读写锁）、信号量、互斥量（条件变量）
## 原子操作
原子操作是指在计算机系统中不可被中断的操作，即操作要么全部执行完毕，要么完全不执行。原子操作的关键特性是它们在执行期间不会被其他线程或进程干扰，从而保证了操作的完整性和一致性。
## 除了互斥锁你还知道什么锁？分别应用于什么场景？
- 读写锁：读写锁允许多个线程同时读取共享资源，但只允许一个线程对线程进行写操作。
- 自旋锁：忙等锁，加锁失败后，线程会忙等待，直到拿到锁。在用户态完成加锁和加锁，不产生线程切换，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源。故适用于临界区很小且锁的持有时间很短的场景，避免线程频繁切换带来的开销。
- 互斥锁：当一个线程尝试获取互斥锁但锁已经被其他线程持有时，该线程会被阻塞并进入睡眠状态，等待锁被释放。避免了CPU资源的浪费，但会引入上下文切换的开销。适用于锁持有时间较长的场景，因为线程在等待锁的过程中会被阻塞，不会消耗CPU资源。

## 自旋锁与互斥锁的区别
![Endianness](自旋锁和互斥锁.png "自旋锁和互斥锁区别示意图")

## 在中断服务程序里面的互斥是使用自旋锁还是信号量？为什么？
- 在中断服务程序中，需要保证对共享资源的访问是互斥的，但由于中断处理需要迅速完成，不能使用会导致阻塞的机制。
- 自旋锁可以在中断上下文中使用，但要确保在中断处理程序中使用自旋锁时禁用中断，避免自旋锁在中断处理中被再次中断，从而导致死锁
- 信号量不适合在中断上下文中使用，因为在中断上下文中不能进行阻塞操作。中断服务程序需要迅速完成，阻塞操作会导致系统响应延迟。
## 死锁的4个条件
- 互斥：资源一次只能被一个线程占用。
- 持有并等待：线程已经持有至少一个资源，并且正在等待获取其他资源，而这些资源被其他线程持有
- 不可抢占：资源不能被强制抢占，只能由持有它的线程显式释放。
- 循环等待：存在一个线程循环等待链，其中每个线程等待下一个线程所持有的资源
  
## 如何避免死锁
- 避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是使用资源有序分配法，来破环环路等待条件。
- 资源有序分配法：线程A和线程B获取资源的顺序要一样，当线程A是先尝试获取资源A，然后尝试获取资源B的时候，线程B同样也是先尝试获取资源A，然后尝试获取资源B。也就是说，所有线程按相同顺序请求资源，避免循环等待。
# 文件系统管理
## 软链接和硬链接
- 软链接：软连接是一个指向另一个文件或目录的特殊文件。它类似于一个快捷方式，包含目标文件的路径。
- 硬连接是文件系统中同一个文件的另一个目录条目。它们共享相同的 inode，因此它们实际上是同一个文件的不同名称。
- 区别：
![Endianness](软链接与硬链接.png "软链接与硬链接锁区别示意图")





# 《计算机网络》



# 《外设基础》
## 中断
### 中断的作用
    中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率，如果没有中断系统，CPU就只能按照原来的程序编写的先后顺序，对各个外设进行轮询，轮询工作效率低，不能及时响应紧急事件。
### 中断的分类
    内部中断和外部中断（硬件中断）。外部中断又分为可屏蔽中断和不可屏蔽中断。内部中断通常分为陷阱、异常、终止。
    
### 中断的整个过程进行描述，从引线触发中断到终端服务函数？
- step1: 中断触发：中断信号由外部设备或内部事件触发，通过中断线发送到处理器的中断控制器。
- step2: 中断响应：处理器检测到中断信号后，完成当前正在执行的指令，并保存当前的程序计数器和状态寄存器。。
- step3: 中断优先级判断：中断控制器判断中断的优先级。如果触发的中断优先级高于当前正在处理的任务，选择合适的中断向量.
- step4: 中断向量表查找：根据中断类型，中断控制器从中断向量表中找到对应的中断服务程序的入口地址。
- step5: 中断服务程序执行：处理器跳转到中断服务程序的入口地址，开始执行中断服务程序。
- step6: 中断结束：中断服务程序执行完毕后，执行中断返回指令，处理器恢复之前保存的程序计数器和状态寄存器，返回到中断前被中断的指令继续执行。  
  
### 中断服务函数带不带参数？为什么？
中断服务函数通常不带参数，以简化中断处理机制，减少延迟，提高响应速度，并简化硬件调用和状态管理。
  
### 不可屏蔽中断
  - 不可屏蔽中断是特殊的硬件中断，具有最高优先级，不能被系统中的其他中断或软件屏蔽。通常处理需要立即响应的紧急事件或严重错误，如硬件故障、电源问题或看门狗定时器超时。
  - NMI触发时，处理器会立即暂停当前任务，保存上下文，并跳转到NMI服务程序处理相关紧急任务。由于NMI无法被屏蔽，服务程序简洁高效，以便快速响应和处理紧急事件。
  
### Linux系统中，中断处理机制
  - 中断触发：由外部硬件设备或内部软件事件引发中断信号的触发，通过中断线通知CPU。
  - 中断响应：CPU停止当前执行的指令，保存当前的上下文到内核堆栈中，中断控制器判断中断优先级后，找到合适的中断向量，通过中断向量表查找中断服务例程的入口地址。
  - 执行中断服务程序：处理器执行最小量的必要工作，确保快速响应。
  - 中断下半部：ISR在中断上下文中运行，无法进行阻塞操作，为减少ISR的执行时间，使用了软中断、任务队列和工作队列等机制来处理需要延迟执行的任务。（软中断用于处理高优先级任务，任务队列用于较低优先级的任务，工作队列允许在进程上下文中执行阻塞操作。）
  - 中断恢复：ISR执行完毕后，恢复被中断的进程上下文，CPU从保存的上下文中恢复寄存器、程序计数器等，继续执行被中断的进程。
    
### Linux中断驱动
中断处理程序必须注册到内核中，通过 request_irq 函数实现，而在设备驱动程序卸载时，使用 free_irq 函数释放中断，确保系统资源的正确管理和释放。
    
### Linux中断与非Linux中断的区别
  - 在Linux系统中，中断处理机制支持动态注册和注销中断处理程序，并提供了多种延迟处理机制，如软中断、任务队列和工作队列，这些机制允许在不同的上下文中执行中断后续处理，确保系统的实时性和响应速度。Linux内核还支持中断负载平衡，在多处理器系统中将中断分配到不同的CPU，以均衡处理负载并提升性能。
  - 非Linux系统中断机制通常更加静态和固定，中断处理程序往往是编译时确定的，缺乏动态注册和复杂的延迟处理机制。非Linux系统中断处理程序通常在硬件中断上下文中完成所有工作，可能会导致较长的中断处理时间，影响系统的实时性和响应能力。
    
## GPIO
- 在输入模式下，GPIO引脚可以读取外部设备的状态。在输出模式下，GPIO引脚可以控制外部设备的状态。
- 八种工作模式
    - 浮空输入：GPIO引脚配置为输入且没有内部上拉或下拉电阻。施密特触发器打开。这种模式适合用于由外部电路提供信号的情况。
    - 上拉输入：GPIO引脚配置为输入并且内部上拉电阻启用。施密特触发器打开。引脚默认处于高电平状态，有助于防止浮空状态。
    - 下拉输入：GPIO引脚配置为输入并且内部下拉电阻启用。施密特触发器打开。引脚默认处于低电平状态，适合需要默认低电平的场景。
    - 模拟功能：GPIO引脚配置为模拟信号的输入或输出，例如用于ADC（模数转换器）或DAC（数模转换器）。
    - 推挽输出模式：GPIO引脚可以输出高电平或低电平。施密特触发器工作，便于读取IO口状态。这种模式适合驱动LED等需要明确电平的设备。
    - 开漏输出模式：GPIO引脚可以输出低电平或高阻抗状态。施密特触发器工作，便于读取IO口状态。通常需要外部上拉电阻，适用于I2C总线等需要线与操作的场合。
    - 推挽式复用
    - 开漏式复用  
## UART
- 介绍：异步的串行通信协议。工作原理是将数据一位一位的进行传输，发送和接收各用一条线。uart接口与外界相连至少需要三条线：TXD、RXD、GND。
- 通信格式：起始位、数据位（通常为8位）、奇偶校验位、停止位。通信双方必须以相同的波特率进行通信，常见的波特率有9600、19200、115200等。
## I2C
### 介绍：同步的串行通信协
  -  双线制通信：I²C使用两条线进行数据传输：数据线（SDA）和时钟线（SCL），这两条线都需要上拉电阻。
  -  主从架构： I²C协议采用主从架构，多主多从。
  -  速度模式： I²C支持多种速度模式：标准模式（最高100 kbps）、快速模式（最高400 kbps等。
### 为什么两条线都需要上拉电阻？
    - 开漏驱动：²C设备通常使用开漏输出，它们只能将线拉低到低电平（逻辑0），但不能主动拉高到高电平（逻辑1）。上拉电阻通过提供一个高电平电压源，确保线路在没有设备拉低时处于高电平状态。
    - 多设备通信：I²C总线是一个多主多从的系统，多个设备可以连接在同一对总线上。上拉电阻使得任何设备在释放总线时，总线能恢复到高电平，从而确保其他设备能够正常通信。ß 
### I²C写数据过程
  - 启动信号：主设备发送一个起始信号，通知所有从设备开始通信。！！！起始信号：是当SDA（数据线）在SCL（时钟线）高电平时从高变低。
  - 发送从设备地址和写操作位：主设备发送从设备的地址，紧接着发送一个表示写操作的位（通常是0）。从设备接收地址，并在地址匹配时应答（ACK）。
  - 发送数据：主设备发送要写入的数据，每发送一个字节数据，从设备都会进行应答（ACK）。这个过程可以重复，直到所有数据字节发送完毕。
  - 停止信号：主设备发送停止信号，通知从设备通信结束。停止信号是当SDA在SCL高电平时从低变高。
### I²C读数据过程
  - 启动信号：主设备发送一个起始信号，通知所有从设备开始通信。！！！起始信号：是当SDA（数据线）在SCL（时钟线）高电平时从高变低。
  - 发送从设备地址和读操作位：主设备发送从设备的地址，紧接着发送一个表示读操作的位（通常是1）。从设备接收地址，并在地址匹配时应答（ACK）。
  - 读取数据：从设备将数据发送给主设备，每发送一个字节数据，主设备都会进行应答（ACK），表示数据接收成功。当所有需要的数据字节读取完毕后，主设备发送非应答（NACK）信号，表示不再需要更多数据。
  - 停止信号：主设备发送停止信号，通知从设备通信结束。停止信号是当SDA在SCL高电平时从低变高。
## SPI
- 介绍：同步的串行通信协。
    -  四线制通信：CS片选线（用于选择需要通信的设备）、SCK时钟线、MOSI主出从入线（主机发送数据到从机）、MISO主入从出线（从机发送数据到主机）。
    -  主从架构： SPI协议采用主从架构。单主多从。
    -  4种工作模式：由时钟极性和相位两两排列组合为4种。
    -  通信过程：SPI是全双工通信，读写时序一起完成。首先CS片选信号先拉低，选择通信从设备，然后MOSI数据线发送数据给从设备，同时从设备通过MISO数据线给主机返回数据。

## UART、IIC、SPI的区别
![Endianness](UART_IIC_SPI.png "UART_IIC_SPI区别示意图")




# 《驱动》
## 讲讲字符设备驱动
### 定义：字符设备驱动是操作系统内核中的一个模块，用于管理和控制字符设备（如：按键、串口等）。字符设备通过字符流方式与用户空间进行交互，设备驱动程序负责处理从用户空间到设备的字符输入和从设备到用户空间的字符输出。
### 实现字符设备驱动的基本步骤：
    - 定义文件操作结构：过定义 file_operations 结构体，指定设备的操作方法，如 open、read、write、release 等。
    - 实现文件操作方法：编写具体的 open、read、write、release 等操作方法。
    - 注册字符设备：使用 register_chrdev 函数注册字符设备。
    - 模块初始化和退出函数：在模块加载和卸载时进行相应的初始化和清理操作。
### 字符设备驱动对应用层的借口API的形式：
    - 字符设备驱动程序通过文件操作接口与应用层交互，应用层程序通过标准的文件操作API访问字符设备。如：open、read、write、iotcl、close。
### file_operation结构体（内核驱动操作函数的集合）
- file_operations 结构体定义了字符设备驱动程序中一组与文件操作相关的函数指针。每个函数指针指向驱动程序实现的相应操作函数。这些操作函数允许内核通过标准文件操作接口与字符设备进行交互。通过实现和注册这些操作函数，驱动程序可以控制设备的打开、关闭、读写等操作。

## 平台（Platform）设备驱动
### 定义：平台设备驱动框架用于处理那些不通过总线，进行枚举和管理的设备。这些设备通常是SOC上的片上设备（如定时器、GPIO 控制器等）。
### 有无设备树的区别
- 在没有设备树的Linux内核下，我们需要分别注册platform_device和platform_driver，分别代表设备和驱动。
- 在有设备树的Linux内核下，设备描述被放到设备树中，不需要编写platform_device，只需编写platform_driver。
### 设备与驱动匹配方式
- OF类型的匹配（即设备树），使用 compatible 属性进行匹配，驱动程序通过定义 of_device_id 结构体数组并将其指向 of_match_table 来实现。
- ACPI 匹配 使用 ACPI 表中的 _HID 或 _CID 属性进行匹配，驱动程序通过定义 acpi_device_id 结构体数组并将其指向 acpi_match_table 来实现。
- id_table 匹配 使用设备标识信息进行匹配，驱动程序通过定义 platform_device_id 结构体数组并将其指向 id_table 来实现。
- name 字段匹配 通过比较驱动和设备的 name 字段进行匹配，不依赖于 compatible 属性。

## linux设备和驱动如何匹配？
- 一般如果系统用了设备树，那就是比较compatible属性，设备节点和驱动匹配成功后自动执行prob函数。
- 如果没用设备树，那就是比较name字段，实际两者比较的都是字符串，相当于名字一样算匹配成功.
  
## compatible属性的作用
- 它的值得是字符串列表，他的作用是将设备和驱动绑定起来

## I2C子系统驱动框架
### 定义
I2C 设备通常使用 I2C 子系统驱动框架来编写驱动程序。I2C 子系统驱动框架在 Linux 内核中提供了对 I2C 总线及其连接设备的支持。具体而言，I2C 子系统框架可以看作是总线驱动框架的一部分，它专门用于处理 I2C 总线上的设备。
### I2C 子系统驱动框架包括两部分
- I2C 总线驱动： 负责管理 I2C 总线本身，通常由 I2C 控制器驱动程序实现。它处理 I2C 总线的初始化、时钟配置、数据传输等。
- I2C 设备驱动： 负责管理连接到 I2C 总线的具体设备，如传感器、EEPROM 等。

# 《嵌入式Linux系统移植》
## 嵌入式linux系统组成
嵌入式linux系统从软件角度主要分为4个主要部分。引导加载程序（bootloader）、Linux内核、文件系统、应用程序。

## 什么是ubootloader?
- 引导加载程序是系统启动的第一个执行代码。它能够识别和加载操作系统内核、初始化硬件设备并配置一些系统参数等，并将控制权传递给内核。
- 此过程有两个阶段
  - 阶段1: 汇编，初始化C怨言环境，初始化DDR，设置栈指针sp等
  - 阶段2: 完成硬件初始化，建立内存映射，将内核Image和设备树文件读取到内存DDR，然后启动内核
## uboot的启动过程？
- 加载kernel的Image。从外部flash中的内核镜像和设备树文件加载至DDR
- 设置启动参数bootargs和biootcmd。
- 启动内核。uboot将启动参数传入内核，并将执行权限交给内核。
## bootargs和bootcmd
- bootargs：它保存着uboot传递给linux内核的参数。
- bootcmd:  它保存着uboot的默认命令，这写命令用于linux内核的启动，可以在uboot启动后进入命令设置。



# 《ARM》


# 《Linux内核基础》
## Linux内核组成
![Endianness](Linux内核组成.png "Linux内核组成")
## 什么是交叉编译工具链？
- 在一种架构上编译另外一种架构的代码，使得运行架构下生成的执行文件，能够在目标架构下运行该执行文件。

## Linux系统中，默认进程的栈的大小
Linux系统中，进程的默认栈空间大小通常是由操作系统内核设置的，默认情况下是8MB。可通过‘ulimit -s stacksize’修改，单位是KB。ulimit命令用于设置或显示进程资源限制。

## Linux内核空间和用户空间通信方式
-  系统调用: 系统调用是用户空间进程与内核交互的主要机制。用户空间进程可以通过系统调用请求内核提供的服务，例如文件操作、进程控制和内存管理。
-  设备文件： 通过设备文件，用户空间进程可以与内核中的设备驱动程序通信。设备文件通常位于 /dev 目录下，用户进程可以使用常规的文件操作（如 open、read、write 和 ioctl）与设备文件进行交互。
-  procfs：用户空间程序通过读写/proc文件系统的特定文件与内核通信，获取或修改内核状态和信息。
-  sysfs：用户空间程序通过读写/sys文件系统中的文件与内核通信，查询或修改设备属性和参数。
-  netlink套接字：用户空间程序通过netlink套接字与内核进行双向通信，用于网络配置、管理等任务。
-  共享内存：用户空间程序通过映射共享内存区域来读写数据，实现高效的数据交换。
-  设备文件：用户空间程序通过打开和读写设备文件与内核进行通信，如串口设备、字符设备等

## 系统调用的过程，以writ1e为例讲讲。
- 用户空间发起write()系统调用，并将参数传递给内核。
- 内核根据系统调用号找到相应的内核函数进行处理如sys_write()
- 内核根据文件描述符找到对应的文件对象，并执行读取
- 在写入操作中，内核将数据从用户空间拷贝到内核空间，并通过文件系统层将数据写入文件或设备。
- 内核可能会通过缓存管理、驱动程序等层次对数据进行处理和传输。
- 处理完成后，内核将结果返回给用户空间，用户空间继续执行下一步操作。

# 《Linux常用命令》
## Linux中查看进程运行状态的命令
### top
实时监视系统的进程活动和系统资源使用情况。查看进程的CPU占用、内存占用、运行时间等信息。
### ps aux
显示所有正在运行的进程的详细信息。

## tar解压缩命令
### 参数
- x：表示解压文件。
- v：可选参数，表示显示详细的解压过程。
- f：后面接需要解压的文件名。
- z：可选参数，用于解压gzip格式的文件。
- j：可选参数，用于解压bzip2格式的文件。
- C：选项表示解压缩到指定目录。
### 解压常用文件
- tar -xvf filename.tar
- tar -xzvf filename.tar.gz
- tar -xjvf filename.tar.bz2

## grep命令
grep 命令用于在文件中搜索指定的模式或关键字，并将匹配的行打印出来。

## root权限
- sudo命令允许普通用户以超级用户（即root用户）的权限来执行命令。
- sudo su 进入root用户下运行程序.



